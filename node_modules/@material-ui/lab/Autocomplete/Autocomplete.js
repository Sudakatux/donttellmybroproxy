"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createFilterOptions", {
  enumerable: true,
  get: function get() {
    return _useAutocomplete2.createFilterOptions;
  }
});
exports.default = exports.styles = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _clsx = _interopRequireDefault(require("clsx"));

var _styles = require("@material-ui/core/styles");

var _Popper = _interopRequireDefault(require("@material-ui/core/Popper"));

var _ListSubheader = _interopRequireDefault(require("@material-ui/core/ListSubheader"));

var _Paper = _interopRequireDefault(require("@material-ui/core/Paper"));

var _IconButton = _interopRequireDefault(require("@material-ui/core/IconButton"));

var _Chip = _interopRequireDefault(require("@material-ui/core/Chip"));

var _Close = _interopRequireDefault(require("../internal/svg-icons/Close"));

var _ArrowDropDown = _interopRequireDefault(require("../internal/svg-icons/ArrowDropDown"));

var _useAutocomplete2 = _interopRequireWildcard(require("../useAutocomplete"));

var styles = function styles(theme) {
  var _option;

  return {
    /* Styles applied to the root element. */
    root: {
      '&:hover $clearIndicatorDirty, &$focused $clearIndicatorDirty': {
        visibility: 'visible'
      }
    },

    /* Pseudo-class applied to the root element if focused. */
    focused: {},

    /* Styles applied to the tag elements, e.g. the chips. */
    tag: {
      margin: theme.spacing(0.5)
    },

    /* Styles applied to the Input element. */
    inputRoot: {
      flexWrap: 'wrap',
      '&[class*="MuiOutlinedInput-root"]': {
        padding: 8,
        '& $input': {
          padding: '10.5px 6px'
        }
      },
      '&[class*="MuiFilledInput-root"]': {
        paddingTop: 21,
        '& $input': {
          paddingTop: 10
        }
      }
    },

    /* Styles applied to the input element. */
    input: {
      width: 0,
      minWidth: 30,
      flexGrow: 1,
      opacity: 0,
      textOverflow: 'ellipsis'
    },

    /* Styles applied to the input element if tag focused. */
    inputFocused: {
      opacity: 1
    },

    /* Styles applied to the clear indictator. */
    clearIndicator: {
      marginRight: -2,
      padding: 4,
      color: theme.palette.action.active,
      visibility: 'hidden'
    },

    /* Styles applied to the clear indictator if the input is dirty. */
    clearIndicatorDirty: {},

    /* Styles applied to the popup indictator. */
    popupIndicator: {
      padding: 2,
      marginRight: -2,
      color: theme.palette.action.active
    },

    /* Styles applied to the popup indictator if the popup is open. */
    popupIndicatorOpen: {
      transform: 'rotate(180deg)'
    },

    /* Styles applied to the popup element. */
    popup: {
      zIndex: 1
    },

    /* Styles applied to the `Paper` component. */
    paper: (0, _extends2.default)({}, theme.typography.body1, {
      margin: '4px 0',
      '& > ul': {
        maxHeight: '40vh',
        overflow: 'auto'
      }
    }),

    /* Styles applied to the `listbox` component. */
    listbox: {
      listStyle: 'none',
      margin: 0,
      padding: '8px 0px',
      position: 'relative'
    },

    /* Styles applied to the loading wrapper. */
    loading: {
      color: theme.palette.text.secondary,
      padding: '14px 16px'
    },

    /* Styles applied to the no option wrapper. */
    noOptions: {
      color: theme.palette.text.secondary,
      padding: '14px 16px'
    },

    /* Styles applied to the option elements. */
    option: (_option = {
      minHeight: 48,
      display: 'flex',
      justifyContent: 'flex-start',
      alignItems: 'center',
      cursor: 'pointer',
      paddingTop: 6,
      outline: 'none',
      // Remove grey highlight
      WebkitTapHighlightColor: 'transparent',
      paddingBottom: 6,
      paddingLeft: 16,
      paddingRight: 16
    }, (0, _defineProperty2.default)(_option, theme.breakpoints.up('sm'), {
      minHeight: 'auto'
    }), (0, _defineProperty2.default)(_option, '&[aria-selected="true"]', {
      backgroundColor: theme.palette.action.selected
    }), (0, _defineProperty2.default)(_option, '&[data-focus="true"]', {
      backgroundColor: theme.palette.action.hover
    }), (0, _defineProperty2.default)(_option, '&[aria-disabled="true"]', {
      opacity: 0.5,
      pointerEvents: 'none'
    }), (0, _defineProperty2.default)(_option, '&:active', {
      backgroundColor: theme.palette.action.selected
    }), _option),

    /* Styles applied to the group's label elements. */
    groupLabel: {
      backgroundColor: theme.palette.background.paper,
      top: -8
    },

    /* Styles applied to the group's ul elements. */
    groupUl: {
      padding: 0
    }
  };
};

exports.styles = styles;

var _ref = _react.default.createElement(_Close.default, {
  fontSize: "small"
});

var _ref2 = _react.default.createElement(_ArrowDropDown.default, null);

var Autocomplete = _react.default.forwardRef(function Autocomplete(props, ref) {
  /* eslint-disable no-unused-vars */
  var _props$autoComplete = props.autoComplete,
      autoComplete = _props$autoComplete === void 0 ? false : _props$autoComplete,
      _props$autoHightlight = props.autoHightlight,
      autoHightlight = _props$autoHightlight === void 0 ? false : _props$autoHightlight,
      _props$autoSelect = props.autoSelect,
      autoSelect = _props$autoSelect === void 0 ? false : _props$autoSelect,
      classes = props.classes,
      className = props.className,
      _props$clearOnEscape = props.clearOnEscape,
      clearOnEscape = _props$clearOnEscape === void 0 ? false : _props$clearOnEscape,
      _props$debug = props.debug,
      debug = _props$debug === void 0 ? false : _props$debug,
      defaultValue = props.defaultValue,
      _props$disableClearab = props.disableClearable,
      disableClearable = _props$disableClearab === void 0 ? false : _props$disableClearab,
      _props$disableCloseOn = props.disableCloseOnSelect,
      disableCloseOnSelect = _props$disableCloseOn === void 0 ? false : _props$disableCloseOn,
      _props$disableListWra = props.disableListWrap,
      disableListWrap = _props$disableListWra === void 0 ? false : _props$disableListWra,
      _props$disableOpenOnF = props.disableOpenOnFocus,
      disableOpenOnFocus = _props$disableOpenOnF === void 0 ? false : _props$disableOpenOnF,
      filterOptions = props.filterOptions,
      _props$filterSelected = props.filterSelectedOptions,
      filterSelectedOptions = _props$filterSelected === void 0 ? false : _props$filterSelected,
      _props$freeSolo = props.freeSolo,
      freeSolo = _props$freeSolo === void 0 ? false : _props$freeSolo,
      getOptionDisabled = props.getOptionDisabled,
      _props$getOptionLabel = props.getOptionLabel,
      getOptionLabel = _props$getOptionLabel === void 0 ? function (x) {
    return x;
  } : _props$getOptionLabel,
      groupBy = props.groupBy,
      idProp = props.id,
      _props$includeInputIn = props.includeInputInList,
      includeInputInList = _props$includeInputIn === void 0 ? false : _props$includeInputIn,
      _props$ListboxCompone = props.ListboxComponent,
      ListboxComponent = _props$ListboxCompone === void 0 ? 'ul' : _props$ListboxCompone,
      _props$loading = props.loading,
      loading = _props$loading === void 0 ? false : _props$loading,
      _props$loadingText = props.loadingText,
      loadingText = _props$loadingText === void 0 ? 'Loadingâ€¦' : _props$loadingText,
      _props$multiple = props.multiple,
      multiple = _props$multiple === void 0 ? false : _props$multiple,
      _props$noOptionsText = props.noOptionsText,
      noOptionsText = _props$noOptionsText === void 0 ? 'No options' : _props$noOptionsText,
      onChange = props.onChange,
      onClose = props.onClose,
      onOpen = props.onOpen,
      open = props.open,
      _props$options = props.options,
      options = _props$options === void 0 ? [] : _props$options,
      _props$PaperComponent = props.PaperComponent,
      PaperComponent = _props$PaperComponent === void 0 ? _Paper.default : _props$PaperComponent,
      _props$PopupComponent = props.PopupComponent,
      PopupComponent = _props$PopupComponent === void 0 ? _Popper.default : _props$PopupComponent,
      renderGroupProp = props.renderGroup,
      renderInput = props.renderInput,
      renderOptionProp = props.renderOption,
      renderTags = props.renderTags,
      valueProp = props.value,
      other = (0, _objectWithoutProperties2.default)(props, ["autoComplete", "autoHightlight", "autoSelect", "classes", "className", "clearOnEscape", "debug", "defaultValue", "disableClearable", "disableCloseOnSelect", "disableListWrap", "disableOpenOnFocus", "filterOptions", "filterSelectedOptions", "freeSolo", "getOptionDisabled", "getOptionLabel", "groupBy", "id", "includeInputInList", "ListboxComponent", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onOpen", "open", "options", "PaperComponent", "PopupComponent", "renderGroup", "renderInput", "renderOption", "renderTags", "value"]);
  /* eslint-enable no-unused-vars */

  var popperRef = _react.default.useRef(null);

  _react.default.useEffect(function () {
    if (popperRef.current) {
      popperRef.current.update();
    }
  });

  var _useAutocomplete = (0, _useAutocomplete2.default)(props),
      getRootProps = _useAutocomplete.getRootProps,
      getInputProps = _useAutocomplete.getInputProps,
      getInputLabelProps = _useAutocomplete.getInputLabelProps,
      getPopupIndicatorProps = _useAutocomplete.getPopupIndicatorProps,
      getClearProps = _useAutocomplete.getClearProps,
      getTagProps = _useAutocomplete.getTagProps,
      getPopupProps = _useAutocomplete.getPopupProps,
      getListboxProps = _useAutocomplete.getListboxProps,
      getOptionProps = _useAutocomplete.getOptionProps,
      value = _useAutocomplete.value,
      dirty = _useAutocomplete.dirty,
      popupOpen = _useAutocomplete.popupOpen,
      focused = _useAutocomplete.focused,
      focusedTag = _useAutocomplete.focusedTag,
      anchorEl = _useAutocomplete.anchorEl,
      setAnchorEl = _useAutocomplete.setAnchorEl,
      inputValue = _useAutocomplete.inputValue,
      groupedOptions = _useAutocomplete.groupedOptions;

  var startAdornment;

  if (multiple && value.length > 0) {
    var tagProps = (0, _extends2.default)({}, getTagProps(), {
      className: classes.tag
    });

    if (renderTags) {
      startAdornment = renderTags(value, tagProps);
    } else {
      startAdornment = value.map(function (option, index) {
        return _react.default.createElement(_Chip.default, (0, _extends2.default)({
          key: index,
          "data-tag-index": index,
          tabIndex: -1,
          label: getOptionLabel(option)
        }, tagProps));
      });
    }
  }

  var defaultRenderGroup = function defaultRenderGroup(params) {
    return _react.default.createElement("li", {
      key: params.key
    }, _react.default.createElement(_ListSubheader.default, {
      className: classes.groupLabel,
      component: "div"
    }, params.key), _react.default.createElement("ul", {
      className: classes.groupUl
    }, params.children));
  };

  var renderGroup = renderGroupProp || defaultRenderGroup;
  var renderOption = renderOptionProp || getOptionLabel;

  var renderListOption = function renderListOption(option, index) {
    var optionProps = getOptionProps({
      option: option,
      index: index
    });
    return _react.default.createElement("li", (0, _extends2.default)({}, optionProps, {
      className: classes.option
    }), renderOption(option, {
      selected: optionProps['aria-selected'],
      inputValue: inputValue
    }));
  };

  return _react.default.createElement("div", (0, _extends2.default)({
    ref: ref,
    className: (0, _clsx.default)(classes.root, className, focused && classes.focused)
  }, getRootProps(), other), renderInput({
    ref: setAnchorEl,
    InputLabelProps: getInputLabelProps(),
    InputProps: {
      className: classes.inputRoot,
      startAdornment: startAdornment,
      endAdornment: _react.default.createElement(_react.default.Fragment, null, disableClearable ? null : _react.default.createElement(_IconButton.default, (0, _extends2.default)({}, getClearProps(), {
        title: "Clear",
        className: (0, _clsx.default)(classes.clearIndicator, dirty && classes.clearIndicatorDirty)
      }), _ref), freeSolo ? null : _react.default.createElement(_IconButton.default, (0, _extends2.default)({}, getPopupIndicatorProps(), {
        title: popupOpen ? 'Close popup' : 'Open popup',
        className: (0, _clsx.default)(classes.popupIndicator, popupOpen && classes.popupIndicatorOpen)
      }), _ref2))
    },
    inputProps: (0, _extends2.default)({
      className: (0, _clsx.default)(classes.input, focusedTag === -1 && classes.inputFocused)
    }, getInputProps())
  }), popupOpen && anchorEl ? _react.default.createElement(PopupComponent, (0, _extends2.default)({
    className: classes.popup,
    style: {
      width: anchorEl ? anchorEl.clientWidth : null
    },
    popperRef: popperRef,
    anchorEl: anchorEl,
    open: true
  }, getPopupProps()), _react.default.createElement(PaperComponent, {
    className: classes.paper
  }, loading ? _react.default.createElement("div", {
    className: classes.loading
  }, loadingText) : null, groupedOptions.length === 0 && !freeSolo && !loading ? _react.default.createElement("div", {
    className: classes.noOptions
  }, noOptionsText) : null, groupedOptions.length > 0 ? _react.default.createElement(ListboxComponent, (0, _extends2.default)({
    className: classes.listbox
  }, getListboxProps()), groupedOptions.map(function (option, index) {
    if (groupBy) {
      return renderGroup({
        key: option.key,
        children: option.options.map(function (option2, index2) {
          return renderListOption(option2, option.index + index2);
        })
      });
    }

    return renderListOption(option, index);
  })) : null)) : null);
});

process.env.NODE_ENV !== "production" ? Autocomplete.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * If `true`, the portion of the selected suggestion that has not been typed by the user,
   * known as the completion string, appears inline after the input cursor in the textbox.
   * The inline completion string is visually highlighted and has a selected state.
   */
  autoComplete: _propTypes.default.bool,

  /**
   * If `true`, the first option is automatically highlighted.
   */
  autoHightlight: _propTypes.default.bool,

  /**
   * If `true`, the selected option becomes the value of the input
   * when the Autocomplete loses focus unless the user chooses
   * a different option or changes the character string in the input.
   */
  autoSelect: _propTypes.default.bool,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: _propTypes.default.object,

  /**
   * @ignore
   */
  className: _propTypes.default.string,

  /**
   * If `true`, clear all values when the user presses escape and the popup is closed.
   */
  clearOnEscape: _propTypes.default.bool,

  /**
   * If `true`, the popup will ignore the blur event if the input if filled.
   * You can inspect the popup markup with your browser tools.
   * Consider this option when you need to customize the component.
   */
  debug: _propTypes.default.bool,

  /**
   * The default input value. Use when the component is not controlled.
   */
  defaultValue: _propTypes.default.any,

  /**
   * If `true`, the input can't be cleared.
   */
  disableClearable: _propTypes.default.bool,

  /**
   * If `true`, the popup won't close when a value is selected.
   */
  disableCloseOnSelect: _propTypes.default.bool,

  /**
   * If `true`, the list box in the popup will not wrap focus.
   */
  disableListWrap: _propTypes.default.bool,

  /**
   * If `true`, the popup won't open on input focus.
   */
  disableOpenOnFocus: _propTypes.default.bool,

  /**
   * A filter function that determins the options that are eligible.
   *
   * @param {any} options The options to render.
   * @param {object} state The state of the component.
   * @returns {boolean}
   */
  filterOptions: _propTypes.default.func,

  /**
   * If `true`, hide the selected options from the list box.
   */
  filterSelectedOptions: _propTypes.default.bool,

  /**
   * If `true`, the Autocomplete is free solo, meaning that the user input is not bound to provided options.
   */
  freeSolo: _propTypes.default.bool,

  /**
   * Used to determine the disabled state for a given option.
   */
  getOptionDisabled: _propTypes.default.func,

  /**
   * Used to determine the string value for a given option.
   * It's used to fill the input (and the list box options if `renderOption` is not provided).
   */
  getOptionLabel: _propTypes.default.func,

  /**
   * If provided, the options will be grouped under the returned string.
   * The groupBy value is also used as the text for group headings when `renderGroup` is not provided.
   *
   * @param {any} options The option to group.
   * @returns {string}
   */
  groupBy: _propTypes.default.func,

  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: _propTypes.default.string,

  /**
   * If `true`, the highlight can move to the input.
   */
  includeInputInList: _propTypes.default.bool,

  /**
   * The component used to render the listbox.
   */
  ListboxComponent: _propTypes.default.elementType,

  /**
   * If `true`, the component is in a loading state.
   */
  loading: _propTypes.default.bool,

  /**
   * Text to display when in a loading state.
   */
  loadingText: _propTypes.default.node,

  /**
   * If true, `value` must be an array and the menu will support multiple selections.
   */
  multiple: _propTypes.default.bool,

  /**
   * Text to display when there are no options.
   */
  noOptionsText: _propTypes.default.node,

  /**
   * Callback fired when the value changes.
   *
   * @param {object} event The event source of the callback
   * @param {any} value
   */
  onChange: _propTypes.default.func,

  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onClose: _propTypes.default.func,

  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see open).
   *
   * @param {object} event The event source of the callback.
   */
  onOpen: _propTypes.default.func,

  /**
   * Control the popup` open state.
   */
  open: _propTypes.default.bool,

  /**
   * Array of options.
   */
  options: _propTypes.default.array,

  /**
   * The component used to render the body of the popup.
   */
  PaperComponent: _propTypes.default.elementType,

  /**
   * The component used to render the popup.
   */
  PopupComponent: _propTypes.default.elementType,

  /**
   * Render the group.
   *
   * @param {any} option The group to render.
   * @returns {ReactNode}
   */
  renderGroup: _propTypes.default.func,

  /**
   * Render the input.
   *
   * @param {object} params
   * @returns {ReactNode}
   */
  renderInput: _propTypes.default.func.isRequired,

  /**
   * Render the option, use `getOptionLabel` by default.
   *
   * @param {any} option The option to render.
   * @param {object} state The state of the component.
   * @returns {ReactNode}
   */
  renderOption: _propTypes.default.func,

  /**
   * Render the selected value.
   *
   * @param {any} value The `value` provided to the component.
   * @returns {ReactNode}
   */
  renderTags: _propTypes.default.func,

  /**
   * The input value.
   */
  value: _propTypes.default.any
} : void 0;

var _default = (0, _styles.withStyles)(styles, {
  name: 'MuiAutocomplete'
})(Autocomplete);

exports.default = _default;