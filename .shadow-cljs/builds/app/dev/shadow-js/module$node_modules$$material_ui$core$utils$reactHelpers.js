["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@material-ui/core/utils/reactHelpers.js"],"~:js","shadow$provide.module$node_modules$$material_ui$core$utils$reactHelpers=function(global,require,module,exports){function setRef(ref,value){\"function\"===typeof ref?ref(value):ref&&(ref.current=value)}global=require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:!0});exports.isMuiElement=function(element,muiNames){return _react.default.isValidElement(element)&&-1!==muiNames.indexOf(element.type.muiName)};exports.setRef=setRef;exports.useForkRef=\nfunction(refA,refB){return _react.default.useMemo(function(){return null==refA&&null==refB?null:function(refValue){setRef(refA,refValue);setRef(refB,refValue)}},[refA,refB])};var _react=global(require(\"module$node_modules$react$index\"))}","~:source","shadow$provide[\"module$node_modules$$material_ui$core$utils$reactHelpers\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMuiElement = isMuiElement;\nexports.setRef = setRef;\nexports.useForkRef = useForkRef;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction isMuiElement(element, muiNames) {\n  return _react.default.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;\n}\n\nfunction setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\nfunction useForkRef(refA, refB) {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior\n   */\n  return _react.default.useMemo(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["isMuiElement","__esModule","value","setRef","current","useForkRef"]],"~:compiled-at",1570449014677,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$material_ui$core$utils$reactHelpers.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,yDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAkBrHC,QAASA,OAAM,CAACC,GAAD,CAAMC,KAAN,CAAa,CACP,UAAnB,GAAI,MAAOD,IAAX,CACEA,GAAA,CAAIC,KAAJ,CADF,CAEWD,GAFX,GAGEA,GAAAE,QAHF,CAGgBD,KAHhB,CAD0B,CAfxBE,MAAAA,CAAyBP,OAAA,CAAQ,kEAAR,CAE7BQ,OAAAC,eAAA,CAAsBP,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAAQ,aAAA,CAMAA,QAAqB,CAACC,OAAD,CAAUC,QAAV,CAAoB,CACvC,MAAOC,OAAAC,QAAAC,eAAA,CAA8BJ,OAA9B,CAAP,EAA6F,EAA7F,GAAiDC,QAAAI,QAAA,CAAiBL,OAAAM,KAAAC,QAAjB,CADV,CALzChB,QAAAC,OAAA,CAAiBA,MACjBD,QAAAiB,WAAA;AAgBAA,QAAmB,CAACC,IAAD,CAAOC,IAAP,CAAa,CAM9B,MAAOR,OAAAC,QAAAQ,QAAA,CAAuB,QAAS,EAAG,CACxC,MAAY,KAAZ,EAAIF,IAAJ,EAA4B,IAA5B,EAAoBC,IAApB,CACS,IADT,CAIO,QAAS,CAACE,QAAD,CAAW,CACzBpB,MAAA,CAAOiB,IAAP,CAAaG,QAAb,CACApB,OAAA,CAAOkB,IAAP,CAAaE,QAAb,CAFyB,CALa,CAAnC,CASJ,CAACH,IAAD,CAAOC,IAAP,CATI,CANuB,CAdhC,KAAIR,OAASN,MAAA,CAAuBP,OAAA,CAAQ,iCAAR,CAAvB,CAZwG;\",\n\"sources\":[\"node_modules/@material-ui/core/utils/reactHelpers.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$material_ui$core$utils$reactHelpers\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.isMuiElement = isMuiElement;\\nexports.setRef = setRef;\\nexports.useForkRef = useForkRef;\\n\\nvar _react = _interopRequireDefault(require(\\\"react\\\"));\\n\\nfunction isMuiElement(element, muiNames) {\\n  return _react.default.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;\\n}\\n\\nfunction setRef(ref, value) {\\n  if (typeof ref === 'function') {\\n    ref(value);\\n  } else if (ref) {\\n    ref.current = value;\\n  }\\n}\\n\\nfunction useForkRef(refA, refB) {\\n  /**\\n   * This will create a new function if the ref props change and are defined.\\n   * This means react will call the old forkRef with `null` and the new forkRef\\n   * with the ref. Cleanup naturally emerges from this behavior\\n   */\\n  return _react.default.useMemo(function () {\\n    if (refA == null && refB == null) {\\n      return null;\\n    }\\n\\n    return function (refValue) {\\n      setRef(refA, refValue);\\n      setRef(refB, refValue);\\n    };\\n  }, [refA, refB]);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"setRef\",\"ref\",\"value\",\"current\",\"_interopRequireDefault\",\"Object\",\"defineProperty\",\"isMuiElement\",\"element\",\"muiNames\",\"_react\",\"default\",\"isValidElement\",\"indexOf\",\"type\",\"muiName\",\"useForkRef\",\"refA\",\"refB\",\"useMemo\",\"refValue\"]\n}\n"]