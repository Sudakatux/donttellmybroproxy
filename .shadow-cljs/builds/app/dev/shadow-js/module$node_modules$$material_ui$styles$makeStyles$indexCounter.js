["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@material-ui/styles/makeStyles/indexCounter.js"],"~:js","shadow$provide.module$node_modules$$material_ui$styles$makeStyles$indexCounter=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.increment=function(){indexCounter+=1;0<=indexCounter&&console.warn(\"Material-UI: you might have a memory leak.\\nThe indexCounter is not supposed to grow that much.\");return indexCounter};var indexCounter=-1E9}","~:source","shadow$provide[\"module$node_modules$$material_ui$styles$makeStyles$indexCounter\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.increment = increment;\n\n/* eslint-disable import/prefer-default-export */\n// Global index counter to preserve source order.\n// We create the style sheet during at the creation of the component,\n// children are handled after the parents, so the order of style elements would be parent->child.\n// It is a problem though when a parent passes a className\n// which needs to override any child's styles.\n// StyleSheet of the child has a higher specificity, because of the source order.\n// So our solution is to render sheets them in the reverse order child->sheet, so\n// that parent has a higher specificity.\nvar indexCounter = -1e9;\n\nfunction increment() {\n  indexCounter += 1;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (indexCounter >= 0) {\n      console.warn(['Material-UI: you might have a memory leak.', 'The indexCounter is not supposed to grow that much.'].join('\\n'));\n    }\n  }\n\n  return indexCounter;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","increment","value"]],"~:compiled-at",1570448038683,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$material_ui$styles$makeStyles$indexCounter.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,gEAAA,CAAoF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG5HC,MAAAC,eAAA,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAAI,UAAA,CAaAA,QAAkB,EAAG,CACnBC,YAAA,EAAgB,CAGM,EAApB,EAAIA,YAAJ,EACEC,OAAAC,KAAA,CAA4D,iGAA5D,CAIJ,OAAOF,aATY,CAFrB,KAAIA,aAAgB,IAjBwG;\",\n\"sources\":[\"node_modules/@material-ui/styles/makeStyles/indexCounter.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$material_ui$styles$makeStyles$indexCounter\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.increment = increment;\\n\\n/* eslint-disable import/prefer-default-export */\\n// Global index counter to preserve source order.\\n// We create the style sheet during at the creation of the component,\\n// children are handled after the parents, so the order of style elements would be parent->child.\\n// It is a problem though when a parent passes a className\\n// which needs to override any child's styles.\\n// StyleSheet of the child has a higher specificity, because of the source order.\\n// So our solution is to render sheets them in the reverse order child->sheet, so\\n// that parent has a higher specificity.\\nvar indexCounter = -1e9;\\n\\nfunction increment() {\\n  indexCounter += 1;\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    if (indexCounter >= 0) {\\n      console.warn(['Material-UI: you might have a memory leak.', 'The indexCounter is not supposed to grow that much.'].join('\\\\n'));\\n    }\\n  }\\n\\n  return indexCounter;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"increment\",\"indexCounter\",\"console\",\"warn\"]\n}\n"]