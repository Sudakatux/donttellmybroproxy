["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-transition-group/cjs/utils/ChildMapping.js"],"~:js","shadow$provide.module$node_modules$react_transition_group$cjs$utils$ChildMapping=function(global,require,module,exports){function getChildMapping(children,mapFn){var result=Object.create(null);children&&_react.Children.map(children,function(c){return c}).forEach(function(child){var JSCompiler_temp_const=child.key;child=mapFn&&(0,_react.isValidElement)(child)?mapFn(child):child;result[JSCompiler_temp_const]=child});return result}function mergeChildMappings(prev,next){function getValueForKey(key){return key in\nnext?next[key]:prev[key]}prev=prev||{};next=next||{};var nextKeysPending=Object.create(null),pendingKeys=[],prevKey;for(prevKey in prev)prevKey in next?pendingKeys.length&&(nextKeysPending[prevKey]=pendingKeys,pendingKeys=[]):pendingKeys.push(prevKey);var childMapping={},nextKey;for(nextKey in next){if(nextKeysPending[nextKey])for(prevKey=0;prevKey<nextKeysPending[nextKey].length;prevKey++)childMapping[nextKeysPending[nextKey][prevKey]]=getValueForKey(nextKeysPending[nextKey][prevKey]);childMapping[nextKey]=\ngetValueForKey(nextKey)}for(prevKey=0;prevKey<pendingKeys.length;prevKey++)childMapping[pendingKeys[prevKey]]=getValueForKey(pendingKeys[prevKey]);return childMapping}function getProp(child,prop,props){return null!=props[prop]?props[prop]:child.props[prop]}exports.__esModule=!0;exports.getChildMapping=getChildMapping;exports.mergeChildMappings=mergeChildMappings;exports.getInitialChildMapping=function(props,onExited){return getChildMapping(props.children,function(child){return(0,_react.cloneElement)(child,\n{onExited:onExited.bind(null,child),in:!0,appear:getProp(child,\"appear\",props),enter:getProp(child,\"enter\",props),exit:getProp(child,\"exit\",props)})})};exports.getNextChildMapping=function(nextProps,prevChildMapping,onExited){var nextChildMapping=getChildMapping(nextProps.children),children=mergeChildMappings(prevChildMapping,nextChildMapping);Object.keys(children).forEach(function(key){var child=children[key];if((0,_react.isValidElement)(child)){var hasPrev=key in prevChildMapping,hasNext=key in\nnextChildMapping,prevChild=prevChildMapping[key],isLeaving=(0,_react.isValidElement)(prevChild)&&!prevChild.props.in;!hasNext||hasPrev&&!isLeaving?hasNext||!hasPrev||isLeaving?hasNext&&hasPrev&&(0,_react.isValidElement)(prevChild)&&(children[key]=(0,_react.cloneElement)(child,{onExited:onExited.bind(null,child),in:prevChild.props.in,exit:getProp(child,\"exit\",nextProps),enter:getProp(child,\"enter\",nextProps)})):children[key]=(0,_react.cloneElement)(child,{in:!1}):children[key]=(0,_react.cloneElement)(child,\n{onExited:onExited.bind(null,child),in:!0,exit:getProp(child,\"exit\",nextProps),enter:getProp(child,\"enter\",nextProps)})}});return children};var _react=require(\"module$node_modules$react$index\")}","~:source","shadow$provide[\"module$node_modules$react_transition_group$cjs$utils$ChildMapping\"] = function(global,require,module,exports) {\n\"use strict\";\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\nexports.getInitialChildMapping = getInitialChildMapping;\nexports.getNextChildMapping = getNextChildMapping;\n\nvar _react = require(\"react\");\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) _react.Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\n\n\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  } // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n\n\n  var nextKeysPending = Object.create(null);\n  var pendingKeys = [];\n\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i;\n  var childMapping = {};\n\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n\n    childMapping[nextKey] = getValueForKey(nextKey);\n  } // Finally, add the keys which didn't appear before any key in `next`\n\n\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nfunction getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return (0, _react.cloneElement)(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\n\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n    if (!(0, _react.isValidElement)(child)) return;\n    var hasPrev = key in prevChildMapping;\n    var hasNext = key in nextChildMapping;\n    var prevChild = prevChildMapping[key];\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)\n\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        in: false\n      });\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n  return children;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["appear","onExited","__esModule","getNextChildMapping","getInitialChildMapping","getChildMapping","exit","mergeChildMappings","enter","in"]],"~:compiled-at",1570449014719,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_transition_group$cjs$utils$ChildMapping.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-transition-group/cjs/utils/ChildMapping.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_transition_group$cjs$utils$ChildMapping\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nexports.__esModule = true;\\nexports.getChildMapping = getChildMapping;\\nexports.mergeChildMappings = mergeChildMappings;\\nexports.getInitialChildMapping = getInitialChildMapping;\\nexports.getNextChildMapping = getNextChildMapping;\\n\\nvar _react = require(\\\"react\\\");\\n\\n/**\\n * Given `this.props.children`, return an object mapping key to child.\\n *\\n * @param {*} children `this.props.children`\\n * @return {object} Mapping of key to child\\n */\\nfunction getChildMapping(children, mapFn) {\\n  var mapper = function mapper(child) {\\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\\n  };\\n\\n  var result = Object.create(null);\\n  if (children) _react.Children.map(children, function (c) {\\n    return c;\\n  }).forEach(function (child) {\\n    // run the map function here instead so that the key is the computed one\\n    result[child.key] = mapper(child);\\n  });\\n  return result;\\n}\\n/**\\n * When you're adding or removing children some may be added or removed in the\\n * same render pass. We want to show *both* since we want to simultaneously\\n * animate elements in and out. This function takes a previous set of keys\\n * and a new set of keys and merges them with its best guess of the correct\\n * ordering. In the future we may expose some of the utilities in\\n * ReactMultiChild to make this easy, but for now React itself does not\\n * directly have this concept of the union of prevChildren and nextChildren\\n * so we implement it here.\\n *\\n * @param {object} prev prev children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @param {object} next next children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @return {object} a key set that contains all keys in `prev` and all keys\\n * in `next` in a reasonable order.\\n */\\n\\n\\nfunction mergeChildMappings(prev, next) {\\n  prev = prev || {};\\n  next = next || {};\\n\\n  function getValueForKey(key) {\\n    return key in next ? next[key] : prev[key];\\n  } // For each key of `next`, the list of keys to insert before that key in\\n  // the combined list\\n\\n\\n  var nextKeysPending = Object.create(null);\\n  var pendingKeys = [];\\n\\n  for (var prevKey in prev) {\\n    if (prevKey in next) {\\n      if (pendingKeys.length) {\\n        nextKeysPending[prevKey] = pendingKeys;\\n        pendingKeys = [];\\n      }\\n    } else {\\n      pendingKeys.push(prevKey);\\n    }\\n  }\\n\\n  var i;\\n  var childMapping = {};\\n\\n  for (var nextKey in next) {\\n    if (nextKeysPending[nextKey]) {\\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\\n        var pendingNextKey = nextKeysPending[nextKey][i];\\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\\n      }\\n    }\\n\\n    childMapping[nextKey] = getValueForKey(nextKey);\\n  } // Finally, add the keys which didn't appear before any key in `next`\\n\\n\\n  for (i = 0; i < pendingKeys.length; i++) {\\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\\n  }\\n\\n  return childMapping;\\n}\\n\\nfunction getProp(child, prop, props) {\\n  return props[prop] != null ? props[prop] : child.props[prop];\\n}\\n\\nfunction getInitialChildMapping(props, onExited) {\\n  return getChildMapping(props.children, function (child) {\\n    return (0, _react.cloneElement)(child, {\\n      onExited: onExited.bind(null, child),\\n      in: true,\\n      appear: getProp(child, 'appear', props),\\n      enter: getProp(child, 'enter', props),\\n      exit: getProp(child, 'exit', props)\\n    });\\n  });\\n}\\n\\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\\n  var nextChildMapping = getChildMapping(nextProps.children);\\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\\n  Object.keys(children).forEach(function (key) {\\n    var child = children[key];\\n    if (!(0, _react.isValidElement)(child)) return;\\n    var hasPrev = key in prevChildMapping;\\n    var hasNext = key in nextChildMapping;\\n    var prevChild = prevChildMapping[key];\\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)\\n\\n    if (hasNext && (!hasPrev || isLeaving)) {\\n      // console.log('entering', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: true,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    } else if (!hasNext && hasPrev && !isLeaving) {\\n      // item is old (exiting)\\n      // console.log('leaving', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        in: false\\n      });\\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\\n      // item hasn't changed transition states\\n      // copy over the last transition props;\\n      // console.log('unchanged', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: prevChild.props.in,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    }\\n  });\\n  return children;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getChildMapping\",\"children\",\"mapFn\",\"result\",\"Object\",\"create\",\"_react\",\"Children\",\"map\",\"c\",\"forEach\",\"child\",\"key\",\"isValidElement\",\"mergeChildMappings\",\"prev\",\"next\",\"getValueForKey\",\"nextKeysPending\",\"pendingKeys\",\"prevKey\",\"length\",\"push\",\"childMapping\",\"nextKey\",\"i\",\"pendingNextKey\",\"getProp\",\"prop\",\"props\",\"__esModule\",\"getInitialChildMapping\",\"onExited\",\"cloneElement\",\"bind\",\"in\",\"appear\",\"enter\",\"exit\",\"getNextChildMapping\",\"nextProps\",\"prevChildMapping\",\"nextChildMapping\",\"keys\",\"hasPrev\",\"hasNext\",\"prevChild\",\"isLeaving\"]\n}\n"]